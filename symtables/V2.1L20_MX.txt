/begin0
T 1
* 00000010:000000C1
# 
R 
L SYSROM:Native Mode Entry
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:000003A5
# 
R 
L SYSROM:DRAW_MEMORY_TEST_MESSAGE
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:00000493
# 
R 
L SYSROM:MEMORY_TEST_FAILED
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:000004E9
# 
R 
L SYSROM:(PROB)MEMORY_TEST_FROM_EDI_FOR_ECX_BYTES
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:0000053F
# 
R 
L SYSROM:MEMTEST_CHECK_READ_BACK
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:000005CD
# 
R 
L SYSROM:(PROB)RETURN_MEMTEST_FAILURE
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00000607
# 
R 
L SYSROM:(PROB)DRAW_MESSAGE_BY_NUMBER
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00000B16
# ECX=Boot Key Combination
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00000B5E
# Check Boot Key Combination
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00000B79
# Setting One-Time Boot Device
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00000B80
# 4C00H=Keyboard Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00000BD2
# 4A00H=JoyPad Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00000D2E
# 4A00H=JoyPad Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:000012F6
# 
R 
L SYSROM:Machine Identification?
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:0000136C
# 
R 
L SYSROM:Read Pad0 Trigger Bits in AL
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001415
# 
R 
L SYSROM:(Prob)Draw Icon
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001D41
# 
R 
L SYSROM:Get Keyboard State EBX=0b43210MNBVCXZLKJHGFDSAPOIUYTREWQ
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001DA4
# Keyboard Command A1=Reset
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001DB1
# 
R 
L SYSROM:Disable Keyboard IRQ and NMI
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001DC1
# 
R 
L SYSROM:(Prob)Get 16-bit Key code
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001DC6
# DH=Incoming_AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001DC8
# Keyboard Command A0=Undocumented
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001DD0
# 1388H=5000
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001DDB
# Keyboard Command A1=Reset
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001DFA
# Check OBF (Keycode)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001DFD
# Jump if no keycode
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E1E
# Restore Incoming_AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001E26
# 
R 
L SYSROM:Wait IBF ready, then Write Keyboard Command(AL)
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001E41
# 
R 
L SYSROM:(Prob)Inkey AH=Keyboard Status 602H, AL=Keycode 600H
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:00001E4B
# 
R 
L Wait for Keyboard Buffer
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E56
# Keyboard Status
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E5E
# Check OBF (Output Buffer)
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:00001E6A
# 
R 
L OBF=1 or TimeOut
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001E81
# 
R 
L SYSROM:Keycode to Flag|0b43210MNBVCXZLKJHGFDSAPOIUYTREWQ
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E83
# 11H='Q'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E87
# 1AH='P'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E8B
# Q->00H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E8F
# 1EH='A'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E93
# 26H='L'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E97
# A->0AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E9B
# 2AH='Z'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001E9F
# 30H='M'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001EA3
# Z->13H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001EA7
# 0BH='0'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001EAB
# 0->1AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001EAF
# 02H='1'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001EB3
# 05H='4'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001EB7
# 4->1EH
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001EDD
# 
R 
L SYSROM:Wait
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001EFF
# 
R 
L SYSROM:Wait by Freerun Timer
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00001F32
# 
R 
L SYSROM:(PROB)DRAW_STRING
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001F44
# CRTC Control?
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001F5C
# (Prob)X
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001F6E
# (Prob)Y
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001F7F
# (Prob)Strlen
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:00001F85
# 
R 
L SYSROM:DRAW_FONT_LOOP
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:00001FD0
# 
R 
L SYSROM:HALT_AFTER_ERROR
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:00001FD4
# 
R 
L SYSROM:Draw Half Pitch Font
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001FD6
# CB000H:Mapped Half-Pitch Font
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00001FDF
# AX=ASCIICode*16
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000010:00001FF5
# 
R 
L SYSROM:(PROB)DRAW_HALF_PITCH_FONT_LOOP
P 
% 0
M 0
/end
/begin0
T 0
* 00000010:00002027
# FDA0H CRT Output Control
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00002031
# 
R 
L SYSROM:CRTC Control?
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:0000219D
# 
R 
L SYSROM:MA/MX HIGHRES Control
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00002442
# 
R 
L SYSROM:SET_PALETTE
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:000024D0
# 
R 
L SYSROM:(PROB)SJIS_TO_JIS
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:00002501
# 
R 
L SYSROM:Check Shift-JIS or ASCII
P 
% 0
M 0
/end
/begin0
T 1
* 00000010:0000251C
# 
R 
L SYSROM:Accessing unknown I/O 479H-4FH
P 
% 0
M 0
/end
/begin0
T 1
* 0000005D:0000020C
# 
R 
L INT 46H(FDC)
P 
% 0
M 0
/end
/begin0
T 0
* 0000005D:0000028B
# Jump to each interrupt
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000110:00005728
# 
R 
L TBIOS:Draw_Mouse_Icon
P 
% 0
M 0
/end
/begin0
T 0
* 00000110:00007B43
# 
R 
L TBIOS:Put_32Pixel_1Bit_Pattern_In_EAX
P 
% 0
M 0
/end
/begin0
T 0
* 00000110:0000D1E4
# 
R 
L TBIOS:BitBlt
P 
% 0
M 0
/end
/begin0
T 0
* 00000110:00011B60
# 
R 
L TBIOS:MouseBIOS
P 
% 0
M 0
/end
/begin0
T 0
* 00000110:00011D50
# 
R 
L TBIOS:MOS_rdpos
P 
% 0
M 0
/end
/begin0
T 0
* 00000110:00012814
# 
R 
L TBIOS:Mouse:Read_Mouse_Motion
P 
% 0
M 0
/end
/begin0
T 1
* 0000039A:00000458
# 
R 
L Wait by I/O 006CH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000000BD
# 
R 
L DISKBIOS:BRANCH_TO_DEVICE
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000000E2
# [BP+03H]=Incoming AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000421:000000EB
# 
R 
L DISKBIOS:Branch to Function
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000001F8
# 
R 
L DISKBIOS:AH=02H Get Disk Status
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000205
# [BP+06H]=Incoming CX
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000209
# [BP+02H]=Incoming AL
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000020C
# Restore
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000421:00000243
# Track 0
R 
L DISKBIOS:(Prob)Find Media Type Loop?
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000245
# Side 0
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000247
# DS:[0040H-] Buffer for sector info.
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000024F
# Read Address Marks
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000251
# DS:[044EH]=Error Code
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000292
# [BP+02H]=Incoming AL
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000295
# AL=Drive
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000002AE
# Bit2:Double-Sided
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000002C6
# [BP+8]=Outgoing DL
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000002F3
# 
R 
L DISKBIOS:(Prob)Cycle media type?
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000036C
# 
R 
L DISKBIOS:AH=09H Read Sector Info
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000003BE
# DSKCHG flag
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000053A
# 
R 
L DISKBIOS:Get Drive-Status Structure Pointer in SI (AL=drive)
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000069E
# [044DH]=Error Code
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000072A
# (Prob)Device Number Error
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000791
# 
R 
L DISKBIOS:(Prob)Clear Timer [0441H] ?BL=02H?
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000079A
# 
R 
L DISKBIOS:(Prob)Clear Timer [0440H] ?BL=02H?
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000007CE
# (Prob)AL=Incoming AL
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000858
# Tentatively no error
R 
L DISKBIOS:Wait for DMA transfer
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000085E
# Tentatively no error
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000867
# CS:0D17 is a callback function (7FH->DS:[0443H])
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000086A
# (Prob)012CH=300 ticks
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000421:00000873
# DS:[0487H] is cleared in FDC IRQ.
R 
L Wait timer up or command finished
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000881
# (Prob)Error Details=Time Over
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000887
# (Prob)Hard Error
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000008A1
# DS:[0453H] is the zero-ext of last FDC status (I/O 0200H)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000008A4
# Clear INDEX/DRQ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000008AC
# Clear except NOTRDY,RECNOTFOUND,CRCERR,BUSY
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000008CD
# [044DH]=Error code
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000008EA
# (Prob)[SI+02H]=Value written to I/O 020CH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000093E
# (Prob)[SI+0BH] is track.
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000A56
# 
R 
L DISKBIOS:(Prob)Reset MODE-B and HISPD for all drives.
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000A59
# (Prob)DS:[04D2H-] Pointers for drive-info structures.
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000A8C
# 
R 
L DISKBIOS:Wait drive ready
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000A91
# Jump if busy
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000AEE
# 
R 
L DISKBIOS:Issue FDC Command
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000AF1
# (Prob)[SI+03H] remembers last-issued FDC command.
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000B97
# 
R 
L DISKBIOS:Check Disk Change if [SI]==1
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000BA8
# 
R 
L DISKBIOS:Select Side([BP+09H])
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000BB7
# (Prob)[SI+01H] is value written to I/O 0208H
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000BC5
# 
R 
L DISKBIOS:Wait for 59us or 100us
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000BD1
# (Prob)Wait for 59(3BH) or 100(64H)us
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000BDB
# 
R 
L DISKBIOS:Read I/O 200H (FDC Status) in AL
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000BE0
# 
R 
L DISKBIOS:Read I/O 208H 3 times.
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000BE7
# 
R 
L DISKBIOS:Check DMA Error
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000BF9
# 
R 
L DISKBIOS:Write AL to I/O 0208H (Drive Control)
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000BFE
# 
R 
L DISKBIOS:Select Drive and Latch HISPD and MODE-B
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000C0D
# 
R 
L DISKBIOS:Unsel Drv, Select Drv,Latch MODE-B and HISPD, then Unsel Drv.
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000C1A
# 
R 
L DISKBIOS:Wait drv ready, Enable IRQ, then write command
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000C22
# (Prob)[SI+01H] remembers value written to I/O 0208H
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000C33
# 
R 
L DISKBIOS:Zero-Ext Status Byte (I/O 200H) to DS:[453H], then FDC CMD D0H(abort).
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000C4D
# 
R 
L DISKBIOS:Write AL to I/O 202H (Track)
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000C52
# 
R 
L DISKBIOS:Write AL to I/O 206H (Data)
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000C67
# 
R 
L DISKBIOS:Setup DMA
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000D17
# 
R 
L DISKBIOS:Callback 7FH->0D47:[0443H]
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000D21
# 
R 
L DISKBIOS:Set up timer.
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000D78
# 
R 
L DISKBIOS:(Prob)Clear Timer
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000D7D
# [0443H] is timer-up flag. 80=Not yet  7F=Up
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000D89
# [0443H] is timer-up flag. 80=Not yet  7F=Up
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00000D93
# 
R 
L DISKBIOS:Floppy Disk IRQ Handler
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00000D97
# (Prob)DS:[0457H]=Drive?
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001181
# (Prob)AH=Status Byte
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001186
# (Prob)AL=Message Byte
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000126D
# 
R 
L DISKBIOS:Set up timer
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000126E
# Call back. IF [0529H]==80H THEN [0529H]=81H
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000012D7
# 
R 
L DISKBIOS:SCSI (Prob) Issue command, return result.
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000012E1
# [0512H]=SCSI Command Pointer
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000012E4
# [0514H]=SCSI Command Segment
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000012E7
# [0516H]=(Prob)Data Destination Pointer
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000012EA
# [0518H]=(Prob)Data Destination Segment
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000134B
# [SI+02H]=0C32H
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000421:0000134F
# 
R 
L DISKBIOS:SCSI Data Transfer Loop
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001351
# Jump if (MSG==1 || C/D==1(CMD/STA/MSG))
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001355
# Jump if REQ==0 (No Transfer Request)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001357
# MSG=0 && C/D==0 && REQ==1 to come here. (Data phase)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001367
# [SI+02H]=0C32H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000136D
# Jump if BUSY
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000136F
# (Prob)Status Byte
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001373
# (Prob)Message Byte
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00001379
# [0516H]=(Prob)Data Destination Pointer
R 
L DISKBIOS:SCSI DMA Transfer
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000137D
# [0518H]=(Prob)Data Destination Segment
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000138B
# [SI+0AH]=00A4H DMA Address Register Low
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001391
# [SI+0CH]=00A4H DMA Address Register High
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000013A5
# [SI+08H]=00A2H DMA Count Register
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00000421:000013B5
# 
R 
L Wait for DMA transfer end?
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000013BE
# [SI+02H]=0C32H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000013C5
# Jump if Ready
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000013C9
# Jump if MSG or CMD/STA/MSG
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000013EB
# Jump if Ready
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000013EF
# Jump if MSG or CMD/STA/MSG
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000140B
# 
R 
L DISKBIOS:SCSI Wait Ready or TimeOut
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000140D
# [SI+02H]=0C32H
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00001445
# [0511H] is it SCSI ID bits?
R 
L DISKBIOS:(Prob)Set SCSI ID Bits and SEL
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001450
# [SI+04H]=0C30H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001456
# [SI+02H]=0C32H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000145C
# Jump if BUSY
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001464
# [SI+04H]=0C30H
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000146B
# [051CH]=Command Counter
R 
L DISKBIOS:INT 48H Command Out Handler
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000146F
# [SI]=0C30H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001472
# [0512H]=SCSI Command Pointer
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00001483
# [SI]=0C30H
R 
L DISKBIOS:INT 48H Status Handler
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001486
# [051AH]=Status byte?
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000148A
# [SI]=0C30H
R 
L DISKBIOS:INT 48H Message-IN Handler
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000148D
# [051BH]=Message byte?
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00001492
# 
R 
L DISKBIOS:SCSI Select DMA Channel
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00001498
# 
R 
L DISKBIOS:SCSI Prepare DMA Not setting ADDR
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000014AF
# 
R 
L DISKBIOS:SCSI Set DMA Mode
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000014BA
# 
R 
L DISKBIOS:SCSI (Prob)SEG:OFFSET to Physical Addr
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000014CB
# 
R 
L DISKBIOS:Wait SCSI BUSY or TimeOut
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000014DF
# Jump if Ready (BUSY=0)
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000014F9
# 
R 
L DISKBIOS:IF [0529H]!=80H THEN [0529H]=82H:Erase Timer
P 
% 0
M 0
/end
/begin0
T 4
* 00000421:0000150D
# 
R 
L Jump Table for SCSI Phase
P 
% 16
M 0
/end
/begin0
T 1
* 00000421:0000151D
# 
R 
L DISKBIOS:SCSI INT 48H Handler (CMD, STA, MSG-IN Phases)
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001525
# [SI+02H]=0C32H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000152B
# Jump if no REQ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000152F
# AL=IO|MSG|CD|0 Defines Phase [2] pp.263
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:0000153B
# 
R 
L DISKBIOS:SCSI Timer Call Back. IF [0529H]==80H THEN [0529H]=81H
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000015AD
# 
R 
L CDROM:BIOS_ENTRY
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001609
# 
R 
L CDROM:BRANCH_TO_FUNCTION
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000173F
# 
R 
L CDROM:FUNCTION_AH=05_READ_SECTOR_HSG
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:00001782
# 
R 
L CDROM:AH=0EH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001BD5
# 
R 
L CDROM:PROBABLY_DRIVE_AND_MPU_RESET
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001C83
# 
R 
L CDROM:ISSUE_A0H(08,01)_THEN_3FH(02,00,0B,08)_SETUP_IRQ_DATA_BLOCK
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001D5C
# 
R 
L CDROM:READ_SECTOR_MAIN
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00001D75
# 
R 
L CDROM:
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002053
# 
R 
L CDROM:MSF_TO_HSG
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002077
# 
R 
L CDROM:HSG_TO_MSF
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000020AC
# 
R 
L CDROM:BIN_TO_BCD
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000020C5
# 
R 
L CDROM:BCD_AL_TO_BIN_AL
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000020E8
# 
R 
L CDROM:MODE2READ_2336(920H)_BYTES
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000020F4
# 
R 
L CDROM:MODE1READ_2048(800H)_BYTES
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002100
# 
R 
L CDROM_RAWREAD_2340(924H)_BYTES
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000210C
# 
R 
L CDROM:ISSUE_DATA_TRANSFER_COMMAND_WAIT_FOR_COMPLETION
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002194
# 
R 
L CDROM:READ_TOC
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000219E
# 
R 
L CDROM:
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000022D7
# 
R 
L CDROM:CHECK_STATUS_CONVERT_TO_ERROR_IF_NOT_SUBQ_17H_18H_19H
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002401
# 
R 
L CDROM:ISSUE_COMMAND_A0H_SETSTATE_WITH_STATUS_REQUEST
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002408
# 
R 
L CDROM:ISSUE_COMMAND_A0H_SETSTATE_WITH_STATUS_REQUEST
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002411
# 
R 
L CDROM:ISSUE_COMMAND_A4(CDDASTOP)_THEN_A0_WAIT_FOR_ERR_OR_(2NDBYTE&0DH)!=0
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002451
# 
R 
L CDROM:ISSUE_COMMAND_3FH_UNKNOWN_COMMAND
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002473
# 
R 
L CDROM_ISSUE_COMMAND_A1(CDDASET)
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000248F
# 
R 
L CDROM:CHECK_STATUS_ERROR_IF_AL!=0_CHECK_SUBSEQUENT_STATUSCODE==AL
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000024C1
# 
R 
L CDROM:CLEAR_8BYTES_FROM_DS:57FH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000024D7
# 
R 
L CDROM:CONVERT_8BYTES_TO_BCD_THEN_ISSUE_COMMAND_IN_DS:57EH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000024DD
# 
R 
L CDROM:CONVERT_1BYTE_TO_BCD_THEN_ISSUE_COMMAND_IN_DS:57EH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000024E7
# 
R 
L CDROM:CONVERT_PARAMS_TO_BCD_WAIT_DRY_THEN_ISSUE_COMMAND_IN_DS:57EH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000251F
# 
R 
L CDROM:IF_STATUS_REQ_THEN_READ_TO_DS:587H_OR_HARD_ERROR_21H_0DH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002565
# 
R 
L CDROM:IF_AH==0_CLEAR_ERROR_CODE_IN_DS:568H
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000256E
# 
R 
L CDROM:SETUP_DMA
P 
% 0
M 0
/end
/begin0
T 1
* 00000421:000025AE
# 
R 
L CDROM:Disk Changed or Drive Not Ready
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000025E2
# 
R 
L CDROM:STATUS_BYTES_IN_587H_TO_BIOS_ERROR_AH_CX
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000026F6
# 
R 
L CDROM:PROBABLY_CHECK_MEDIA_CHANGE_AND_CACHE_TOC_IF_CHANGED
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000275F
# 
R 
L CDROM:CACHE_TOC_DS:564,565,567=1,MEDIA_CHANGED_ERROR
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:0000277C
# 
R 
L CDROM:PROBABLY_CHECK_DRIVE_AND_MEDIA_STATUS
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000027D2
# 
R 
L CDROM:COPY_8BYTES_FROM_DS:57FH_TO_DS:599H
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000027DC
# 
R 
L CDROM:COPY_8BYTES_FROM_DS:599H_TO_DS:57FH
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000027F3
# 
R 
L CDROM:INT_FDH_CX=1EH_Probably_30us_WAIT
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:000027FB
# 
R 
L CDROM:SETUP_TIMER_FOR_TIMEOUT
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002845
# 
R 
L CDROM:TIMEOUT_TIMER_CALLBACK
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002850
# 
R 
L CDROM:INTERRUPT_HANDLER
P 
% 0
M 0
/end
/begin0
T 0
* 00000421:00002926
# 
R 
L CDROM:Probably_CACHE_TOC_IN_INTERNAL_BUFFER
P 
% 0
M 0
/end
/begin0
T 0
* 00000D47:0000057C
# 
R 
L CDROMBIOS:2ND_BYTE_OF_STATUS_CODE_IF_NO_ERROR(00H_xx_xx_xx)
P 
% 0
M 0
/end
/begin0
T 1
* 00000F45:00000AD0
# 
R 
L IO.SYS(?):SET_PALETTE
P 
% 0
M 0
/end
/begin0
T 1
* 00001048:00000000
# 
R 
L IO.SYS Entry
P 
% 0
M 0
/end
/begin0
T 2
* 00001048:000001DB
# 
R 
L IO.SYS:MAIN
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:00000264
# AL=40H is RAM/ROM disk
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:000002A7
# (Prob)Jump to MSDOS.SYS
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:00002C9C
# 
R 
L ????:SHOOT_INT_93H
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:0000362D
# (Prob)Jump if 1.44MB?
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:00003632
# Jump if 2D/2DD
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001048:00003697
# 
R 
L (Prob)Error:Single-Sided Disk Not Supported
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:00004A89
# 
R 
L NOT_CX_Bytes_From_DS:[SI]
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:00004AFB
# 
R 
L Calculate_Check_Sum
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:00004C24
# 
R 
L Call[FFFB:0019]
P 
% 0
M 0
/end
/begin0
T 0
* 00001048:00004C2D
# 
R 
L Call[FFFB:001E]
P 
% 0
M 0
/end
/begin0
T 1
* 00001674:00000000
# 
R 
L Hanging part of IO.SYS.  Copies itself to AF37:0000
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00000000
# 
R 
L MSDOS.SYS Entry
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:0000046C
# SI=Temporary DPB  DI=Permanent DPB
R 
L MOVDPB
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000471
# [046AH]=INITSS,[0468H]=INITSP
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000479
# [DMAADD+2]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000047E
# [DPBHEAD] Address of first DPB
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000482
# [DPBHEAD+2]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000487
# [SFT_ADDR+2]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000048C
# [NUMIO]
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:00000492
# ES:[SI+DPB_NEXT_DPB+2]
R 
L SETFINDPB
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000496
# [SI+DPB_FIRST_ACCESS] Never accessed before
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000049B
# 20H=DPBSIZ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004A3
# [SI+DPB_NEXT_DPB+2] (Prob)Terminating the chain
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004AA
# (Prob)SYSBUF+0FH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004AD
# (Prob)To allow 10000H, the MSB is kept in the CF
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004AF
# But Carry is from SUB SI,20H, most likely CF=0
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004B3
# Pretty much same as saying DI=6AAH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004BD
# [BUFHEAD+2]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004C1
# [BUFHEAD]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004C5
# [DI+BUFDRV]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004CB
# (Prob)[DI+NEXTBUF]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004D0
# (Prob)[DI+NEXTBUF+2]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004D9
# [ENDMEM]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004E1
# ES:[CurrentPDB](Supposed to be DS:[CurrentPDB])
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004E5
# ES:[CurrentPDB] Two lines have no effect.
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004F0
# [AREANA_HEAD]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004F7
# (Prob)[ARENA_SIGNATURE],ARENA_SIGNATURE_END
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000004FC
# (Prob)[ARENA_OWNER],ARENA_OWNER_SYSTEM
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000502
# [ENDMEM]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000050A
# [ARENA_SIZE]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000050E
# 009EH=OFFSET SFTABL+SFT_TABLE Point to sft 0
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000514
# Adjust Refcount
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00000515
# 0026H=OFFSET SYSINITVAR
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000012D8
# 
R 
L DOS:LDS_SI,CS:[051EH]
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000017A2
# 
R 
L DOS:
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:000018B6
# Create a valid DPB from a user-specified BPB  Input ES:BP DPB DS:SI BPB
R 
L SETDPB
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018B8
# Skip over dpb_drive and dpb_UNIT
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018BC
# dpb_sector_size (Bytes per logical sector)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018C2
# dpb_cluster_mask (#sec/cluster-1 Assuming # is 2^n)
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:000018C7
# 
R 
L LOG2LOOP
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:000018D1
# 
R 
L SAVLOG
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018D3
# dpb_cluster_shift
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018D6
# dpb_first_FAT Start of FAT (# of reserved sectors)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018D8
# dpb_FAT_count Number of FATs
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018DC
# dpb_root_entries Number of directory entries
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018DF
# Directory entries per sector
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018E2
# Cause Round Up
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018EA
# Number of directory sectors
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018ED
# Skip dpb_first_sector
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018EE
# Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018F0
# ES:[BP+dpb_media] Media byte
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018F4
# Number of sectors in a FAT
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018F5
# dpb_FAT_size
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018F6
# Space occupied by all FATs
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018F8
# ES:[BP+dpb_first_FAT]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018FC
# dpb_dir_sector
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018FD
# Add number of directory sectors
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000018FF
# ES:[BP.dpb_first_sector]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001903
# ES:[BP+DSKSIZ]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001907
# Sectors in data area
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001909
# dpb_cluster_shift
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000190B
# Div by sectors/cluster
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000190E
# ES:[BP+dpb_max_cluster]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001912
# Current directory is root
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001918
# (Prob)Number of free clusters (-1 if unknown)
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:0000191F
# 
R 
L (Prob)CREATE_PROCESS_DATA_BLOCK
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:0000199C
# 
R 
L SETMEM
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001A58
# 
R 
L DOS:CAPITALIZE_AL
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001A64
# 
R 
L DOS:CX=STRLEN(DS:SI)
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001A72
# 
R 
L DOS:CX=STRLEN(DS:SI)
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001A7C
# 
R 
L DOS:SWAP(DS,ES);SWAP(SI,DI)
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001AE4
# 
R 
L DOS:NOP
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00001AEC
# 
R 
L DOS:NOP
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00001AF4
# 
R 
L Just Return. NOP
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00001AF5
# 
R 
L INT 2AH AX=8002H
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00001AFC
# 
R 
L Just Return. NOP
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00001AFD
# 
R 
L INT 2AH AX=8102H
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00001B04
# 
R 
L INT 2AH AH=84H
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00001F09
# 
R 
L (Prob)OUTMES
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00004738
# 
R 
L Call STRATEGY & INTERRUPT of device driver in DS:SI
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000473B
# Must be Jump Vector for STRATEGY
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000474C
# Must be Jump Vector for INTERRUPT
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00004E1C
# 
R 
L DOS:IF_AL=='/'_THEN_AL=BACKSLASH;ZF=(AL==BACKSLASH);
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00004E29
# 
R 
L DOS:(PROB)ZF=(AL_IS_NOT_THE_FIRST_BYTE_OF_KANJI)
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000057F6
# 
R 
L DOS:
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006208
# 
R 
L DOS:(PROB)MAKE_FULL_PATH_NAME
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:0000659E
# 
R 
L DOS:GET_DRIVE_NUMBER_FROM_FILE_NAME_IN_AL
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:000069A5
# 
R 
L IF(DOS:SS:[050DH]=FFH){CL=CH;SS[0508H]=CL;}
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00006AA0
# 
R 
L INT 2AH Handler (Probably Tentative)
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:00006AA1
# 
R 
L DOSINIT
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AA3
# CS:[02F2H]=[ENDMEM] (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AA8
# CS:[0468H]=[INITSP] (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AAD
# CS:[046AH]=[INITSS] (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AB6
# 6E16H=INITSTACK
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AB9
# SS=CS:[004AH]=[DEVHEAD+2] (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006ABE
# SS=CS:[0048H]=[DEVHEAD] (MSINIT.ASM) DS:SI Points to CONSOLE Device
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AC3
# Setting INT 2AH is not in MSDOS 2.0 source
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AC6
# DS=0 INT VECTORS
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006ACB
# VECTOR (OFFSET) for INT 2AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AD0
# VECTOR (SEGMENT) for INT 2AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006ADA
# DI=OFFSET SFTAB1+SFT_TABLE (MSINIT.ASM) Points to sft 0
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AE0
# Refcount (STOSB in MSDOS 2.0)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AE3
# Access rd/wr
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AE6
# Attribute Byte
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006AE9
# 0C0H|ISCIN(01)|ISCOUT(02)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B0D
# 04H=SDEVATT,03H=ISCIN OR ISCOUT (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B11
# SS=CS:[0032H]=[BCON] (MSINIT.ASM
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B16
# SS=CS:[0034H]=[BCON+2] (MSINIT.ASM
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:00006B1B
# AUX devices
R 
L CHAR_INIT_LOOP
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B20
# [SI+SDEVATT],ISCLOCK (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B26
# [BCLOCK] (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B2B
# [BCLOCK+2] (MSINIT.ASM)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B30
# 6E18H=MEMSTRT (MSINIT.ASM) ES:BP points to DPB
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:00006B33
# Next Device
R 
L PERDRV
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B3D
# [SI+SDEVATT],DEVTYP
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B44
# [CALLUNIT] (DEVCALL+0DH ?)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B4B
# [SI+SDEVNAME],CL Number of units in name field
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B4E
# [NUMIO]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B55
# [NUMIO]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B5C
# [CALLBPB] In:Pointer to string after DEVICE=  Out:BPB array pointer
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:00006B61
# 
R 
L PERUNIT
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B73
# [BP+DPB_SECTOR_SIZE]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B77
# AX,[MAXSEC]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B7E
# [MAXSEC],AX
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B82
# NOTMAX
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B89
# [BP+DPB_DRIVE]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006B8D
# [BP+DPB_UNIT]
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:00006BA2
# 
R 
L CONTINIT
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BA4
# First byte after current DPBs
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BA6
# [0036H]=[MAXSEC]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BAA
# 6AA0H=OFFSET SYSBUF
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BAF
# (Prob)0010H=BUFINSIZ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BB2
# (Prob)[DPBHEAD] True start of DPBs
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BB7
# 6AA0H=OFFSET SYSBUF
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BBD
# Allocate buffer space
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BBF
# True address of free memory
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BC4
# OFFSET MEMSTRT
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BC7
# 0018H=DPB_NEXT_DPB
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BCA
# [NUMIO]
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 00001679:00006BD0
# 0020H=DPBSIZ
R 
L TRUEDPBAD
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BD4
# DPBSIZ-2
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BD9
# DPBSIZ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BDF
# End of list
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BE0
# True start of free space (round up to segment)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BE7
# Number of segments for DOS resources
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BEB
# First free segment
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BF0
# [ENDMEM]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BF6
# [ENDMEM] Not doing anything
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006BFC
# ES:[DSKCHRET+3]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C07
# INITBASE+2
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C0C
# (Prob)4FC8=OFFSET DIVOV Set default divide trap address (INT 0?)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C12
# (Prob)CS for INT 0
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C18
# Set 9 segments (skip 2 between each)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C22
# INITBASE
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C25
# 1679:1187 IRET
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C2B
# Set IP 9 times
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C45
# (Prob)Long Jump to Entry Point
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C53
# (Prob)ADDR_INT_ABORT
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C59
# (Prob)ADDR_INT_COMMAND
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C5F
# (Prob)[ADDR_INT_TERMINATE]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C65
# (Prob)[ADDR_INT_TERMINATE+2]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C69
# (Prob)BIOS DISK READ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C6F
# (Prob)BIOS DISK WRITE
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C75
# (Prob)End But Stay Resident
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C7F
# 2AH*4
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C8A
# Zero interrupt locs for ints 2AH-2FH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C8D
# 0358H=INITBLOCK
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006C9C
# [CurrentPDB]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CA1
# Save COMMAND address
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CA2
# [ENDMEM]
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CA7
# Basic Header
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CAC
# 0018H=PDB_JFN_Table
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CB1
# 0,1, and 2 are CON devices
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CB5
# 11H=FilePerProc-3
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CB8
# Rest are unused
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CBC
# 002CH=SFT_ADDR+2
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CC0
# OFFSET HEADER
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CD5
# 6E18H=MEMSTRT
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CD8
# [DPBHEAD] Place to move DPBs to
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 00001679:00006CEE
# [DEVCALL.REQLEN],DINITHL
R 
L CHARINIT (MSINIT.ASM)
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CF4
# [DEVCALL.REQUNIT],0
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006CFA
# [DEVCALL.REQFUNC],DEVINIT
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006D00
# [DEVCALL.REQSTAT],0
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001679:00006D0A
# OFFSET DEVCALL
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00001E54:00003AB2
# DOS:Jump to AH
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 00005844:000007DE
# 
R 
L CONTROL.EXE:LOAD_DRIVE_R.IMG_TO_PHYS:81000000
P 
% 0
M 0
/end
/begin0
T 0
* 00005844:000008B1
# 
R 
L CONTROL.EXE:(PROB)MAIN_FUNCTION
P 
% 0
M 0
/end
/begin0
T 0
* 00005844:00000C81
# 
R 
L CONTROL.EXE:SET_INT_E4H_HANDLER_IF_NOT_SET
P 
% 0
M 0
/end
/begin0
T 0
* 00005844:00000CEA
# 
R 
L CONTROL.EXE:INT_93H_AH=56H(RESUME)_THEN_INT_93H_AH_55H(PAUSE)_IF_PLAYING
P 
% 0
M 0
/end
/begin0
T 0
* 00005844:000017A2
# 
R 
L CONTROL.EXE:(PROB)LOAD_AND_INIT_OAK40ROM
P 
% 0
M 0
/end
/begin0
T 0
* 000059C4:00000010
# 
R 
L ????:INT_91H_AH=02H
P 
% 0
M 0
/end
/begin0
T 0
* 000059C4:00000015
# 
R 
L ????:INT_AFH_AH=05H_READ_SYSTEM_INFO_TO_DS:[0FF1H]_FD:[0FEFH]=3130H
P 
% 0
M 0
/end
/begin0
T 0
* 000059C4:000000F4
# 
R 
L ????:INT_93H_AX=52C0H_CH=FFH_SET_CDROM_AUTO_STOP_TIME
P 
% 0
M 0
/end
/begin0
T 0
* 000059C4:0000012B
# 
R 
L ????:ANALYZE_COMMAND_ARGS
P 
% 0
M 0
/end
/begin0
T 1
* 0000AF37:00000000
# 
R 
L IO.SYS Fragment. Copied from 1674:0000.
P 
% 0
M 0
/end
/begin0
T 0
* 0000AF37:0000016C
# Calling DOSINIT
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 0000B000:00000004
# 
R 
L Boot Sector Entry
P 
% 0
M 0
/end
/begin0
T 2
* 0000B000:00000053
# 
R 
L FDBOOT:MAIN
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:00000062
# [0020H]=Sector
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:00000067
# [0021H]=Side
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:00000085
# No Error -> Jump to B000:0085 (Next line)
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:00000099
# Compare 'FBIOS'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000000B3
# DX=[0050:0000]=1048H
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000000BA
# Jump by RETF to 1048:0000
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 0000B000:000000C7
# 
R 
L (Prob)Read IO.SYS
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000000D6
# [0031]=Number of sectors to read
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000000DC
# 78H=120 sectors
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 0000B000:000000DF
# 
R 
L Read Disk Loop
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000000E7
# Next Sector
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000000F7
# Next Side
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000000FE
# Next Cylinder
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:00000102
# Move pointer forward by 400H bytes
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 0000B000:000001B1
# 
R 
L FDBOOT:(Prob)Read Sector
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000001B9
# DS:[0030]=Device ID
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000001BC
# DS:[0022]=Cylinder
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000001C0
# DS:[0020]=Sector DS:[0021]=Side
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000001C4
# DS:[0021]=Number of sectors
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000001C8
# DS:[0033]=Address DS:[0035]=Segment
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000B000:000001E1
# (Prob)Retry Count
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 0000B000:000001E9
# 
R 
L Return
P 
% 0
M 0
/end
/begin0
T 1
* 0000B000:000001EC
# 
R 
L FDBOOT:(Prob)Restore DS:[0030] is device ID
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00000365
# Calling Get Keyboard State
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:0000036A
# Check Boot Key Combination 'DEBUG'
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:000005CA
# 5D00H='->' Icon. I've never seen it.
R 
L 
P 
% 0
M 0
/end
/begin0
T 2
* 0000FC00:0000060D
# 
R 
L SYSROM:Boot Device Loop
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:000006B6
# 4200H=CD-ROM Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:000006EC
# 4700H=Hard Disk Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:0000070E
# 4000H=Floppy Disk Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00000718
# 4600H=External Floppy Disk Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:0000071E
# (Prob)EDI=VRAM Pointer
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:0000072A
# 13900H='0',13A00H='1'
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:0000077A
# 
R 
L SYSROM:(Prob)Try One Boot Device
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00000786
# 
R 
L SYSROM:Wait by Freerun Timer times C350H times.
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00000C3F
# Jump if 386SX
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00000C53
# 5100H=Clock Icon
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00000C99
# Jump if 386SX
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00000CC8
# Jump to IPL
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00000F07
# 
R 
L SYSROM:(Prob)Draw Icon
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00000F7A
# 
R 
L SYSROM:(Prob)Call Native Mode Service Routine 0010:000000B7
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00000FB6
# 
R 
L SYSROM:(Prob)Call Native Mode Service Routine 0010:000000CB
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00000FCA
# 
R 
L SYSROM:(Prob)Memory Test
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001773
# 
R 
L Calculate_Checksum_52HBytes_From_DX
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:000017DB
# 
R 
L IN_AL,3000H+(DX-7C1H>=0?(DX-7C1H)/0400H:(DX<<1))
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:000017E7
# 
R 
L Read_TwoBytes_from_3000H+AL*2
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001A49
# 
R 
L SYSROM:HSG_TO_MSF
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001A60
# 
R 
L SYSROM:BIN_TO_BCD
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001AA2
# 
R 
L SYSROM:CDROM_READ_SECTOR_PARAM_IN_IO_3B60
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001AD6
# 
R 
L SYSROM:
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001B34
# 
R 
L SYSROM:CDROM_CMD_A0H_THEN_RECEIVE_STATUS_BYTES
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001B60
# 
R 
L SYSROM:STORE_00_TO_8BYTES_FROM_IO_3B60H
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001B75
# 
R 
L SYSROM:CDROM_WAIT_DRY_THEN_BIN_TO_BCD_THEN_ISSUE_CMD_IN_IO_3B50H
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001BF5
# 
R 
L SYSROM:CDROM_TRY_READ_STATUS_OR_RETURN{21,0D,00,00}_IF_NO_STATUS
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001C79
# 
R 
L SYSROM:UPDATE_DMA_COUNT_IF_NO_ERROR
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001C86
# 
R 
L SYSROM:SET_DMA_COUNT
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001C9D
# 
R 
L 
P 
% 0
M 1
/end
/begin0
T 0
* 0000FC00:00001CA8
# 
R 
L SYSROM:READ_DMA_ADDRESS_IN_BX_AX
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001CBF
# 
R 
L SYSROM:SETUP_DMA
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001CF7
# 
R 
L SYSROM:CDROM_TURN_ON_DMA_WAIT_FOR_DTSF_CLEAR
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001D5B
# 
R 
L SYSROM:CDROM_STATUS_IN_IO_3B70H_TO_BIOS_ERROR_CODE
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001E1F
# 
R 
L SYSROM:WAIT_30US_THEN_READ_ADDITIONA_STATUS_BYTES?
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00001E54
# 
R 
L SYSROM:CDROM_CMD_A0H_THEN_INTERPRET_STATUS
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00001EB8
# 
R 
L SYSROM:JMP FC00:1EDA
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00001EDA
# 
R 
L SYSROM:(Prob)Disk BIOS Equivalent
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00002293
# 
R 
L SYSROM:Set up DMA Address
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:000022B0
# 
R 
L 
P 
% 0
M 1
/end
/begin0
T 0
* 0000FC00:000022BC
# 
R 
L 
P 
% 0
M 1
/end
/begin0
T 0
* 0000FC00:00002405
# 
R 
L 
P 
% 0
M 1
/end
/begin0
T 2
* 0000FC00:0000298D
# 
R 
L SCSI:WAIT_READY_LOOP
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00002995
# Check REQ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00002997
# Jump if no REQ
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:000029CC
# Check BUSY flag (1==BUSY)
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00002A92
# 
R 
L SYSROM:Write AH to DMA mode-control register.
P 
% 0
M 1
/end
/begin0
T 0
* 0000FC00:00002AA9
# 
R 
L 
P 
% 0
M 1
/end
/begin0
T 0
* 0000FC00:00002AAF
# Jump if DMA count is up.
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00002AB1
# 
R 
L 
P 
% 0
M 1
/end
/begin0
T 0
* 0000FC00:00002AB7
# Jump if not DATA PHASE
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00002ABB
# Jump if BUSY
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00002AC5
# 
R 
L 
P 
% 0
M 1
/end
/begin0
T 0
* 0000FC00:00002AC9
# Jump if not BUSY
R 
L 
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00002ACF
# Jump if DATA PHASE
R 
L 
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00002AD2
# 
R 
L SYSROM:DX|BX to Physical Address
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00002AE4
# 
R 
L SYSROM:Set DMA Address and Count
P 
% 0
M 0
/end
/begin0
T 1
* 0000FC00:00002B00
# 
R 
L SYSROM:Enable (Unmask) DMA Channel 1
P 
% 0
M 0
/end
/begin0
T 0
* 0000FC00:00002ED2
# 
R 
L SYSROM:WAIT_BY_FREERUN_TIMER
P 
% 0
M 0
/end
/begin0
T 1
* 0000FFFB:00000000
# 
R 
L SYSROM:RESET_VECTOR_REIPL
P 
% 0
M 0
/end
/begin0
T 1
* 0000FFFB:00000005
# 
R 
L SYSROM:RESET_VECTOR_TOSV11
P 
% 0
M 0
/end
/begin0
T 1
* 0000FFFB:00000014
# 
R 
L SYSROM:Disk BIOS Equivalent
P 
% 0
M 0
/end
/begin0
T 1
* 0000FFFB:00000019
# 
R 
L SYSROM:(PROB)Service_Routine
P 
% 0
M 0
/end
/begin0
T 1
* FFFF0000:00000000
# 
R 
L NULL
P 
% 0
M 0
/end
/begin0
T 0
* FFFF0000:00BAA600
# 
R 
L 
P 
% 0
M 1
/end
